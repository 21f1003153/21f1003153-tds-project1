import os
import re
import json
import time
import uuid
import base64
import webbrowser
import requests
from dotenv import load_dotenv
from pydantic import BaseModel
from fastapi import FastAPI, HTTPException, BackgroundTasks
from fastapi.responses import Response

# -------------------------------
# 0) Env & constants
# -------------------------------
load_dotenv()

# GitHub / OpenAI (AIPipe) config
GITHUB_TOKEN = os.getenv("GITHUB_TOKEN")
GITHUB_OWNER = os.getenv("GITHUB_OWNER")
AIPIPE_KEY   = os.getenv("OPENAI_API_KEY")
AIPIPE_URL   = os.getenv("OPENAI_BASE_URL", "https://aipipe.org/openai/v1/chat/completions")

# optional: used only if request doesn't include evaluation_url
FALLBACK_EVALUATOR_URL = os.getenv("EVALUATOR_URL", "").strip()

HEADERS = {
    "Authorization": f"Bearer {GITHUB_TOKEN}",
    "Accept": "application/vnd.github+json",
    "X-GitHub-Api-Version": "2022-11-28"
}

SECRETS_FILE = os.getenv("SECRETS_FILE", "secrets.json")

app = FastAPI()

# -------------------------------
# 1) Models & auth helpers
# -------------------------------
def load_secrets():
    with open(SECRETS_FILE, "r", encoding="utf-8") as f:
        return json.load(f)

def verify_secret(email: str, secret: str) -> bool:
    secrets = load_secrets()
    return secrets.get(email) == secret

class TaskRequest(BaseModel):
    email: str
    secret: str
    task: str
    round: int | None = None
    nonce: str | None = None
    brief: str | None = None
    checks: list = []
    evaluation_url: str | None = None
    attachments: list = []

# -------------------------------
# 2) Startup: verify GitHub token
# -------------------------------
def verify_github_token() -> bool:
    print("üîç Verifying GitHub token permissions...")
    r = requests.get("https://api.github.com/user", headers=HEADERS)
    if r.status_code == 200:
        user = r.json().get("login", "?")
        print(f"‚úÖ Token is valid. Authenticated as: {user}")
        return True
    print(f"‚ùå Token check failed: {r.status_code}, {r.text}")
    return False

@app.on_event("startup")
def startup_check():
    if not verify_github_token():
        print("‚ö†Ô∏è GitHub token invalid or missing permissions. Please fix .env before continuing.")

# -------------------------------
# 3) Utility helpers
# -------------------------------
def decode_data_uri(uri: str):
    """
    Decode a data URI (data:<mime>;base64,<data>) and return bytes.
    Returns None if it‚Äôs not valid base64 or not a data URI.
    """
    m = re.match(r"data:(.*?);base64,(.*)", uri or "")
    if not m:
        return None
    try:
        return base64.b64decode(m.group(2))
    except Exception:
        return None

def save_attachment_bytes(name: str, data: bytes, outdir="attachments"):
    os.makedirs(outdir, exist_ok=True)
    path = os.path.join(outdir, name)
    with open(path, "wb") as f:
        f.write(data)
    return path

# -------------------------------
# 4) GitHub helpers
# -------------------------------
def repo_exists(owner: str, repo: str) -> bool:
    url = f"https://api.github.com/repos/{owner}/{repo}"
    r = requests.get(url, headers=HEADERS)
    return r.status_code == 200

def create_repo(repo_name: str, description="Generated by LLM-Deploy"):
    url = "https://api.github.com/user/repos"
    payload = {"name": repo_name, "private": False, "description": description}
    r = requests.post(url, headers=HEADERS, json=payload)
    if r.status_code not in (200, 201):
        raise Exception(f"‚ùå Repo creation failed: {r.status_code}, {r.text}")
    return r.json()

def upload_file(owner: str, repo: str, path: str, content_bytes: bytes, message="Add or update file"):
    url = f"https://api.github.com/repos/{owner}/{repo}/contents/{path}"
    b64 = base64.b64encode(content_bytes).decode("utf-8")
    payload = {"message": message, "content": b64, "branch": "main"}

    # include existing 'sha' if file exists
    check = requests.get(url, headers=HEADERS)
    if check.status_code == 200:
        payload["sha"] = check.json()["sha"]

    r = requests.put(url, headers=HEADERS, json=payload)
    if r.status_code not in (200, 201):
        raise Exception(f"‚ùå Upload failed: {r.status_code}, {r.text}")
    return r.json()

def enable_github_pages(owner: str, repo: str):
    url = f"https://api.github.com/repos/{owner}/{repo}/pages"
    payload = {"source": {"branch": "main", "path": "/"}}
    r = requests.post(url, headers=HEADERS, json=payload)
    if r.status_code not in (200, 201, 204):
        print(f"‚ö†Ô∏è GitHub Pages enable failed: {r.status_code}, {r.text}")
    else:
        print(f"üåç GitHub Pages enabled for {repo}")

def get_latest_commit_sha(owner: str, repo: str) -> str | None:
    url = f"https://api.github.com/repos/{owner}/{repo}/commits/main"
    r = requests.get(url, headers=HEADERS)
    if r.status_code == 200:
        return r.json().get("sha")
    print(f"‚ö†Ô∏è Failed to fetch commit SHA: {r.status_code}, {r.text}")
    return None

# -------------------------------
# 5) LLM page generator (AIPipe)
# -------------------------------
def generate_app_from_brief(brief: str | None, attachments=None) -> str:
    print("üß† Generating app from LLM...")

    headers = {
        "Authorization": f"Bearer {AIPIPE_KEY}",
        "Content-Type": "application/json",
    }

    prompt = f"""
Generate a complete, working single-page HTML + JavaScript quiz app.
The app should follow this brief:
{brief}

Requirements:
- Valid standalone HTML document
- Inline JS and CSS only
- Clean white background
- Header-style blue bar with white text: "Quiz Time!"
- Radio options stacked vertically
- Blue "Submit" button; after submit, show score and a "Retake Quiz" button
No markdown fences or explanations‚Äîjust the HTML.
"""

    try:
        r = requests.post(AIPIPE_URL, headers=headers, json={
            "model": "gpt-4-turbo",
            "messages": [{"role": "user", "content": prompt}]
        })
        r.raise_for_status()
        html = r.json()["choices"][0]["message"]["content"]
        html = html.replace("```html", "").replace("```", "").strip()
        if "<html" not in html.lower():
            html = f"<!DOCTYPE html><html><body>{html}</body></html>"
        print("‚úÖ LLM app generated successfully.")
        return html
    except Exception as e:
        print("‚ö†Ô∏è LLM generation failed, using fallback template:", e)
        return f"""<!DOCTYPE html>
<html><body>
  <button style='background:blue;color:white;font-size:20px;border:none;padding:10px 20px;border-radius:8px;'>Quiz Time!</button>
  <p>{brief or "No brief provided."}</p>
  <p>‚ö†Ô∏è LLM failed to generate output.</p>
</body></html>"""

# -------------------------------
# 6) Evaluator callback (BUILD 7‚Äì8)
# -------------------------------
def report_to_evaluator(payload: dict, repo_url: str, pages_url: str):
    """POST back to evaluation_url with required JSON. Retries 1,2,4,8s."""
    eval_url = (payload.get("evaluation_url") or FALLBACK_EVALUATOR_URL).strip() if payload else ""
    if not eval_url:
        print("‚ö†Ô∏è No evaluation_url provided; skipping evaluator report.")
        return

    owner = GITHUB_OWNER
    repo_name = repo_url.split("/")[-1]
    commit_sha = get_latest_commit_sha(owner, repo_name) or "N/A"

    data = {
        "email": payload.get("email"),
        "task": payload.get("task"),
        "round": payload.get("round", 1),
        "nonce": payload.get("nonce", ""),
        "repo_url": repo_url,
        "commit_sha": commit_sha,
        "pages_url": pages_url,
    }

    backoff = [1, 2, 4, 8]
    last_err = None
    for delay in backoff:
        try:
            r = requests.post(eval_url, json=data, timeout=20)
            if r.ok:
                print(f"üì© Reported to evaluator at {eval_url} (status {r.status_code}).")
                return
            else:
                print(f"‚ö†Ô∏è Evaluator POST failed: {r.status_code}, {r.text}")
        except Exception as e:
            last_err = e
            print("‚ö†Ô∏è Evaluator POST exception:", e)
        time.sleep(delay)

    if last_err:
        print("‚ùå Final evaluator callback error:", last_err)

# -------------------------------
# 7) Background task
# -------------------------------
def handle_task(payload: dict):
    print("\nüì¶ Received task:", payload.get("task"))

    # 7.1 Save any attachments (data URIs)
    attachments = payload.get("attachments", []) or []
    saved_files: list[str] = []
    for a in attachments:
        data = decode_data_uri(a.get("url", ""))
        if data:
            path = save_attachment_bytes(a["name"], data)
            saved_files.append(path)
            print(f"üß© Saved attachment: {path}")
        else:
            print(f"‚ö†Ô∏è Skipped invalid attachment: {a.get('name')}")

    # 7.2 Generate the HTML
    html = generate_app_from_brief(payload.get("brief"), attachments)
    out_path = os.path.join("attachments", "index.html")
    os.makedirs(os.path.dirname(out_path), exist_ok=True)
    with open(out_path, "w", encoding="utf-8") as f:
        f.write(html)
    print(f"üåê Generated webpage at: {out_path}")

    if os.getenv("ENV", "local") == "local":
        webbrowser.open(f"file://{os.path.abspath(out_path)}")

    # 7.3 GitHub: create/update repo and push files
    base_repo_name = str(payload.get("task", "tds-project1")).replace("/", "-")
    repo_name = base_repo_name
    owner = GITHUB_OWNER

    if repo_exists(owner, repo_name):
        print(f"üîÅ Repo '{repo_name}' exists. Updating instead of creating...")
    else:
        print(f"üöÄ Creating repo: {repo_name}")
        repo_info = create_repo(repo_name)
        owner = repo_info["owner"]["login"]

    print(f"üì§ Uploading latest files to {repo_name}...")
    with open(out_path, "rb") as f:
        upload_file(owner, repo_name, "index.html", f.read(), "Add index.html")
    time.sleep(1)

    for p in saved_files:
        with open(p, "rb") as f:
            upload_file(owner, repo_name, os.path.basename(p), f.read(), f"Add {os.path.basename(p)}")
        time.sleep(1)

    readme_text = f"# {repo_name}\n\nAuto-generated app for task: {payload.get('task')}"
    upload_file(owner, repo_name, "README.md", readme_text.encode(), "Add README")

    license_text = "MIT License\n\nCopyright (c) 2025 Monalisa"
    upload_file(owner, repo_name, "LICENSE", license_text.encode(), "Add LICENSE")
    time.sleep(1)

    # 7.4 Enable GitHub Pages
    enable_github_pages(owner, repo_name)
    pages_url = f"https://{owner}.github.io/{repo_name}/"
    repo_url  = f"https://github.com/{owner}/{repo_name}"
    print(f"üåç Pages enabled at: {pages_url}")
    print(f"‚úÖ Repo ready at: {repo_url}")

    # 7.5 Report back to evaluator (BUILD step 7‚Äì8)
    report_to_evaluator(payload, repo_url, pages_url)

# -------------------------------
# 8) Routes
# -------------------------------
@app.post("/task")
async def receive_task(req: TaskRequest, background_tasks: BackgroundTasks):
    if not verify_secret(req.email, req.secret):
        raise HTTPException(status_code=403, detail="invalid secret")

    # queue background processing and return quickly (BUILD step 3)
    background_tasks.add_task(handle_task, req.dict())
    return {"status": "accepted"}

@app.get("/task")
def task_info():
    return {"hint": "POST JSON here with fields: email, secret, task, round, nonce, evaluation_url"}

@app.get("/")
def root():
    return {"message": "Server is running fine!"}

@app.get("/favicon.ico")
async def favicon():
    # no content; keeps browser happy
    return Response(status_code=204)
